import concurrent.futures
import timeit
from logging import DEBUG, INFO
from typing import List, Optional, Tuple, cast

from flwr.common import (
    Disconnect,
    EvaluateIns,
    EvaluateRes,
    FitIns,
    FitRes,
    ReadIns,
    ReadRes,
    Reconnect,
    Weights,
    parameters_to_weights,
    weights_to_parameters,
)
from threading import Condition, Lock
from flwr.common.logger import log
from flwr.server.client_manager import ClientManager
from flwr.server.client_proxy import ClientProxy
from flwr.server.history import History
from flwr.server.strategy import FedAvg, Strategy
from flwr.server.strategy.aggregate import aggregate
from flwr.server.server_base import ServerBase

FitResultsAndFailures = Tuple[List[Tuple[ClientProxy, FitRes]], List[BaseException]]
EvaluateResultsAndFailures = Tuple[
    List[Tuple[ClientProxy, EvaluateRes]], List[BaseException]
]
ReconnectResultsAndFailures = Tuple[
    List[Tuple[ClientProxy, Disconnect]], List[BaseException]
]


def set_strategy(strategy: Optional[Strategy]) -> Strategy:
    """Return Strategy."""
    return strategy if strategy is not None else FedAvg()


class ServerSSP(ServerBase):
    def __init__(
        self,
        staleness_bound: int,
        num_clients: int,
        client_manager: ClientManager,
        strategy: Optional[Strategy] = None
    ) -> None:
        self._client_manager: ClientManager = client_manager
        self.weights: Weights = []
        self.strategy: Strategy = set_strategy(strategy)
        self.staleness_bound = staleness_bound
        self.num_clients = num_clients
        self.global_clock = -1
        self.cond_var = Condition()
        self.lock = Lock()
        self.client_clocks = {}
        self.history_res = []

    def fit(self, num_rounds: int) -> History:
        history = History()
        # Initialize weights by asking one client to return theirs
        self.weights = self._get_initial_weights()
        res = self.strategy.evaluate(weights=self.weights)
        if res is not None:
            log(
                INFO,
                "initial weights (loss/accuracy): %s, %s",
                res[0],
                res[1],
            )
            history.add_loss_centralized(rnd=0, loss=res[0])
            history.add_accuracy_centralized(rnd=0, acc=res[1])

        # sample clients
        clients = self.client_manager().sample(self.num_clients)

        # Start tracking client clocks
        for client in clients:
            self.client_clocks[client.cid] = -1

        #  Run federated learning for num_rounds for each client
        with concurrent.futures.ThreadPoolExecutor() as executor:
            futures = [
                executor.submit(self.fit_client, c, num_rounds, self.staleness_bound) for c in clients
            ]
            concurrent.futures.wait(futures)

        for future in futures:
            future.result()

        # Bookkeeping
        end_time = timeit.default_timer()
        # elapsed = end_time - start_time
        log(INFO, "[TIME] FL finished")
        return history

    def fit_client(self, client: ClientProxy, num_rounds: int, staleness_bound: int):
        start_time = timeit.default_timer()
        for current_round in range(0, num_rounds):
            log(INFO, "server starts round %s for client %s", current_round, client.cid)

            # prepare FitIns
            log(INFO, "server send FitIns(clock=%d) to client %s", current_round, client.cid)
            parameters = weights_to_parameters(self.weights)
            config = {"is_final_round": "0"}
            if current_round == num_rounds-1:
                config["is_final_round"] = "1"
            fit_ins = FitIns(parameters, config, current_round)

            # fit_client
            reply = client.fit(fit_ins)
            if isinstance(reply, ReadIns):
                log(INFO, "server receives ReadIns from client %s", client.cid)
                # reply is ReadIns
                weights = self.get_fresh_weights(reply)

                # handle client's Read
                read_res = ReadRes(weights_to_parameters(weights), fit_ins, self.global_clock)
                log(INFO, "server sends back ReadRes(clock=%d) to client %s", read_res.clock, client.cid)
                reply = client.read(read_res)

            # reply is FitRes
            fit_res = reply
            log(INFO, "server receives FitRes(clock=%d) from client %s", current_round, client.cid)

            with self.lock:
                global_clock_updated = self.update_clock(client.cid, current_round)
                log(INFO, "server updates clock. client_clocks: %s, global_clock: %s", self.client_clocks, self.global_clock)
                weights_prime = aggregate([(parameters_to_weights(fit_res.parameters), fit_res.num_examples)])
                if weights_prime is not None:
                    self.weights = weights_prime

                # Evaluate model using strategy implementation, if global clock is updated
                # Centralized evaluation
                if global_clock_updated:
                    res_cen = self.strategy.evaluate(weights=self.weights)
                    if res_cen is not None:
                        if self.need_switch_staleness_bound(res_cen):
                            self.staleness_bound -= 1
                        self.history_res.append(res_cen)
                        loss_cen, acc_cen = res_cen
                        log(
                            INFO,
                            "fit progress: (%s, %s, %s, %s)",
                            self.global_clock,
                            loss_cen,
                            acc_cen,
                            timeit.default_timer() - start_time,
                        )


    def evaluate(self, rnd):
        # distributed evaluation
        client_instructions = self.strategy.configure_evaluate(
            rnd=rnd, weights=self.weights, client_manager=self._client_manager
        )
        if not client_instructions:
            log(INFO, "evaluate: no clients sampled, cancel federated evaluation")
            return None
        log(
            DEBUG,
            "evaluate: strategy sampled %s clients",
            len(client_instructions),
        )

        # Evaluate current global weights on those clients
        results_and_failures = evaluate_clients(client_instructions)
        results, failures = results_and_failures
        log(
            DEBUG,
            "evaluate received %s results and %s failures",
            len(results),
            len(failures),
        )
        # Aggregate the evaluation results
        loss_aggregated = self.strategy.aggregate_evaluate(rnd, results, failures)
        _ = shutdown(clients=list(self.client_manager().all().values()))
        return loss_aggregated, results_and_failures

    def get_fresh_weights(self, ins: ReadIns) -> Weights:
        with self.cond_var:
            while not self.global_clock >= ins.min_clock:
                log(INFO, "WAIT in get_fresh_weights: global_clock=%s, min_clock=%s", self.global_clock, ins.min_clock)
                self.cond_var.wait()

            return self.weights

    def update_clock(self, cid, current_round) -> bool :
        self.client_clocks[cid] = current_round

        min_client_clock = float('inf')
        for cid, clock in self.client_clocks.items():
            min_client_clock = min(min_client_clock, clock)

        if min_client_clock > self.global_clock:
            self.global_clock = min_client_clock
            with self.cond_var:
                self.cond_var.notify_all()
            return True

        return False

    def need_switch_staleness_bound(self, new_res) -> bool :
        return False

    def client_manager(self) -> ClientManager:
        """Return ClientManager."""
        return self._client_manager

    def _get_initial_weights(self) -> Weights:
        """Get initial weights from one of the available clients."""
        random_client = self._client_manager.sample(1)[0]
        parameters_res = random_client.get_parameters()
        return parameters_to_weights(parameters_res.parameters)


def evaluate_clients(
    client_instructions: List[Tuple[ClientProxy, EvaluateIns]]
) -> EvaluateResultsAndFailures:
    """Evaluate weights concurrently on all selected clients."""
    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = [
            executor.submit(evaluate_client, c, ins) for c, ins in client_instructions
        ]
        concurrent.futures.wait(futures)
    # Gather results
    results: List[Tuple[ClientProxy, EvaluateRes]] = []
    failures: List[BaseException] = []
    for future in futures:
        failure = future.exception()
        if failure is not None:
            failures.append(failure)
        else:
            # Success case
            results.append(future.result())
    return results, failures


def evaluate_client(
    client: ClientProxy, ins: EvaluateIns
) -> Tuple[ClientProxy, EvaluateRes]:
    """Evaluate weights on a single client."""
    evaluate_res = client.evaluate(ins)
    return client, evaluate_res


def shutdown(clients: List[ClientProxy]) -> ReconnectResultsAndFailures:
    """Instruct clients to disconnect and never reconnect."""
    reconnect = Reconnect(seconds=None)
    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = [executor.submit(reconnect_client, c, reconnect) for c in clients]
        concurrent.futures.wait(futures)
    # Gather results
    results: List[Tuple[ClientProxy, Disconnect]] = []
    failures: List[BaseException] = []
    for future in futures:
        failure = future.exception()
        if failure is not None:
            failures.append(failure)
        else:
            result = future.result()
            results.append(result)
    return results, failures


def reconnect_client(
    client: ClientProxy, reconnect: Reconnect
) -> Tuple[ClientProxy, Disconnect]:
    """Instruct a single client to disconnect and (optionally) reconnect
    later."""
    disconnect = client.reconnect(reconnect)
    return client, disconnect
