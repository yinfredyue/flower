This file explains the design of SSP on Flower.

We try to build SSP using existing abstractions, instead of from scratch. Currently, the Join
method opens a bi-directional channel between the server and the client. All message exchanges
go through: client - client-side queue - gRPC - gRPC_bridge - client_proxy - server. We follow
this approach.

We introduce the Read operation, as explained in the SSP paper. In BSP Flower, every `fit`
operation requires server sending parameter to the client. In SSP, `fit` doesn't include
the parameter, and parameter is always fetched through the Read operation.

When client receives a FitIns, it checks if cached parameter is fresh enough. If yes, it fit
the model and sends back a FitRes to server. Otherwise, it sends back a ReadIns to server. When
receiving ReadIns, the server sends back the updated model (and wait if necessary) in ReadRes. 
When the client receives ReadRes, it updates its cached paramter, and re-start the aborted fit
operation. Eventually, the client sends back FitRes.

New message types are introduced in tranport.proto, protoc is used to generate _pb2.py, 
_pb2_grpc.py; mypy_protobuf is used to generate _pb2.pyi (mainly for type annotation?).

We introduced new classes like ServerSSP, NumPyClientSPP, etc. 

The goal is to run examples/quickstart_pytorch as SSP.
